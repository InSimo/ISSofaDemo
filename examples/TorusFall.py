import ISSofaPython as Sofa
import simulation as sofasimulation
import json
from math import sin, cos, pi
import numpy as np
import os

####################
# CONFIGURATION
####################

GPU = False  # NOT IMPLEMENTED
VISUAL = True
COLLISION = True

# Methods selection
# uncomment one for each alternative

# ALOOP = "FREEMOTION"
ALOOP = "FREEMOTIONTASK"


# SOLVER
# CG       : EulerImplicit + Conjugate Gradient (same as original video but
#            badly tuned / only worked well with the GPU volume contacts)
# EIGENDOMAIN : EulerImplicit + EigenLLTDomainSolver + GenericCC
# LDL      : EulerImplicit + BSCLDLMT + GenericCC (as used in current
#            simulations)
# LDLDOMAIN: EulerImplicitDomainSolver + BSCLDLComplianceSolver +
#            BSCLDLDomainSolver (new option, should be equivalent to LDL here)

# SOLVER = "CG"
# SOLVER = "LDL"
SOLVER = "EIGENDOMAIN"

# COLLISION MODELS
# SOFA    : flat triangle mesh + NewProximityIntersection
# SOFALMD : flat triangle mesh + LocalMinDistance (WIP)

CM = "SOFA"
# CM = "SOFALMD"

# or override in ENV
ALOOP = os.getenv("ALOOP", ALOOP)
SOLVER = os.getenv("SOLVER", SOLVER)
CM = os.getenv("CM", CM)

# Performance / complexity parameters
# NBOBJECT  : original scene is with 40 objects, but 20 is enough to get a
#             shorter test sim
# CMLEVEL   : collision model mesh refinements, between 0 and 2
#             (each level adds ~4x as many contacts)
# DOFLEVEL  : mechanical mesh refinements, can be positive or negative
#             (adding one level adds ~2x as many dofs)
# DOFLEVEL -4:   129 points,   392 elements
# DOFLEVEL -3:   229 points,   736 elements
# DOFLEVEL -2:   344 points,  1256 elements (default)
# DOFLEVEL -1:   648 points,  2528 elements
# DOFLEVEL  0:  1104 points,  4528 elements (as original video)
# DOFLEVEL  1:  1852 points,  8128 elements
# DOFLEVEL  2:  3420 points, 15856 elements

NBTHREAD = int(os.getenv("NBTHREAD", 6))
NBOBJECT = int(os.getenv("NBOBJECT", 10))
NBOBSTACLE = int(os.getenv("NBOBSTACLE", 16))
NBSOLVER = int(os.getenv("NBSOLVER", NBOBJECT))
CMLEVEL = int(os.getenv("CMLEVEL", 0))
DOFLEVEL = int(os.getenv("DOFLEVEL", -4))

# Contacts parameters
# CONTACT_MU : friction. !=0 creates 3x as many constraint lines
#              (very expensive, but good stess test / benchmark)
CONTACT_MU = 0
# CONTACT_MU = 0.3
CONTACT_MU = float(os.getenv("CONTACT_MU", CONTACT_MU))

# Procedural fall generation parameters
SCENE_SCALE = 10.0
FALL_RADIUS = 40.0
OBSTACLE_RADIUS = 100.0
FALL_V0 = 100.0
FALL_H0 = 30.0
FALL_HFIXED = 200.0
FALL_INTERVAL = 16.0
FALL_MINDIST = 55.0

# Visual parameters

OBJECT_COLORS = [[46/255.0,  31/255.0,  22/255.0, 1.0],
                 [202/255.0, 128/255.0,  55/255.0, 1.0],
                 [240/255.0, 239/255.0, 220/255.0, 1.0]]

OBSTACLE_COLOR = [0.23, 0.25, 0.42, 1.0]
FLOOR_MATERIAL = """floor
Ambient 1 0.104 0.092 0.08 1.0
Diffuse 1 0.52 0.46 0.4 1.0
Specular 0 1.0 1.0 1.0 1.0
Emissive 0 0.05 0.05 0.05 0.0 Shininess 0 20"""


####################
# assets
####################

if CMLEVEL == 0:
    torus_collision_mesh_file = "mesh/torus1-16x8.obj"
elif CMLEVEL == 1:
    torus_collision_mesh_file = "mesh/torus1-32x16.obj"
else:
    torus_collision_mesh_file = "mesh/torus1.obj"  # 64x32
torus_visual_mesh_file = "mesh/torus1.obj"
torus_dilated_mesh_file = "mesh/torus1-dilated-05.obj"
cylinder_visual_mesh_file = "mesh/cylinder.obj"

# tetra mesh is generated by stuffing with a specific grid cell size
torus_volume_cell_size = 0.55*SCENE_SCALE*pow(2.0, -DOFLEVEL/3.0)

####################
# helpers
####################

rrand_seed = 12345  # initial seed, must be less than 2147483647


def rrand(range_min, range_max):
    """Simple custom random function so that we always generate the same scene
    without depending on the python version
    Return a float value between range_min and range_max (inclusive)"""
    global rrand_seed
    t = 48271 * (rrand_seed % 44488) - 3399 * \
        int((rrand_seed-(rrand_seed % 44488)) / 44488)
    rrand_seed = (t if t > 0 else t + 2147483647)
    return range_min + (range_max-range_min)*float(rrand_seed) / 2147483647


def material_from_color(c):
    if len(c) == 3:
        c = [c[0], c[1], c[2], 1.0]
    return "mat Ambient 1 {} {} {} {} Diffuse 1 {} {} {} {} \
              Specular 1 1 1 1 Emissive 0 {} {} {} {} Shininess 1 40""".format(
        c[0]*0.2, c[1]*0.2, c[2]*0.2, c[3],
        c[0], c[1], c[2], c[3],
        c[0], c[1], c[2], c[3])

####################
# controllers
####################


class EnableAfterController(Sofa.PythonController):
    def __init__(self, node, name, start_time, constraint, collision_model):
        super(EnableAfterController, self).__init__()
        self.setName(name)
        self.constraint = constraint
        self.collision_model = collision_model
        self.start_time = start_time
        self.enabled = False
        self.node = node
        if node:
            node.addObject(self)
        self.addCallback(Sofa.AnimateBeginEvent(0), self.onAnimateBegin)

    def onAnimateBegin(self, e):
        time = self.getContext().getTime()
        self.enabled = (time >= self.start_time)
        if self.constraint:
            self.constraint.fixAll.value = not self.enabled
        if self.collision_model:
            self.collision_model.active.value = self.enabled

####################
# scene creation
####################
# Simple methods for adding deformable torus and fixed cylinders
# (translation from old php+xml version)
# BUG: RegularGridTopology::parse() method needs valid n, min and max, so they
# #    need to be sent as strings...
# BUG: I failed to get OglModel to parse color, so using material instead


def add_solver(node, index):
    # make sure all solvers use the same damping
    rayleighMass = 0.1
    rayleighStiffness = 0.1
    if SOLVER == "CG":
        odesolver = node.createObject(
            'EulerImplicitSolver', name="ODE{}".format(index),
            rayleighMass=rayleighMass, rayleighStiffness=rayleighStiffness)
        linsolver = node.createObject(
            'CGLinearSolver', name="CG{}".format(index),
            iterations=25, tolerance=1.0e-10, threshold=1.0e-10)
    elif SOLVER == "LDL":
        odesolver = node.createObject(
            'EulerImplicitSolver', name="ODE{}".format(index),
            rayleighMass=rayleighMass, rayleighStiffness=rayleighStiffness)
        linsolver = node.createObject(
            'SparseLDLSolver', name="LDL{}".format(index))
        correction = node.createObject(
            "GenericConstraintCorrection", name="CC{}".format(index))
    elif SOLVER == "EIGENDOMAIN":
        odesolver = node.createObject(
            'EulerImplicitSolver', name="ODE{}".format(index),
            rayleighMass=rayleighMass, rayleighStiffness=rayleighStiffness)
    else:
        raise "Invalid SOLVER value " + SOLVER
    return node


def add_object(node, index, translation, rotation, velocity, volume_mesh,
               collision_mesh, visual_mesh):

    object_color = OBJECT_COLORS[((index + 2) / 4) % len(OBJECT_COLORS)]

    # input (transforms)
    volume_rest_position = volume_mesh.outputPoints
    volume_tetrahedra = volume_mesh.outputTetrahedra
    volume_transform = node.createObject(
        "TransformEngine", name="Torus{}VXForm".format(index))
    volume_transform.input_position.setParent(volume_rest_position)
    volume_transform.translation.setValue(list(translation))
    volume_transform.rotation.setValue(list(rotation))
    volume_position = volume_transform.output_position
    volume_vel_transform = node.createObject(
        "TransformEngine", name="Torus{}VVel".format(index))
    volume_vel_transform.input_position.setParent(volume_rest_position)
    volume_vel_transform.translation.setValue(list(velocity))
    volume_vel_transform.scale.setValue([0, 0, 0])
    volume_velocity = volume_vel_transform.output_position
    collision_rest_position = collision_mesh.position
    collision_triangles = collision_mesh.triangles
    visual_rest_position = visual_mesh.position
    visual_triangles = visual_mesh.triangles

    # dofs
    dofs_topology = node.createObject(
        "TetrahedronSetTopologyContainer", name="Torus{}Topo".format(index))
    dofs_topology.position.setParent(volume_rest_position)
    dofs_topology.tetrahedra.setParent(volume_tetrahedra)
    dofs_mstate = node.createObject(
        "MechanicalObject", template="Vec3", name="Torus{}State".format(index))
    dofs_mstate.rest_position.setParent(volume_rest_position)
    dofs_mstate.position.setParent(volume_position)
    dofs_mstate.velocity.setParent(volume_velocity)
    node.createObject(
        "TetrahedronSetTopologyModifier", name="Torus{}Mod".format(index))
    node.createObject(
        "TetrahedronSetGeometryAlgorithms", name="Torus{}Algo".format(index))
    mass = node.createObject(
        "UniformMass", totalmass=20.0)
    fem = node.createObject(
        "TetrahedronFEMForceField",
        name="Torus{}FEM".format(index),
        youngModulus=50.0, poissonRatio=0.45, method="polar")

    # compliance (depending on the SOLVER)
    if SOLVER == "CG":
        correction = node.createObject(
            "UncoupledConstraintCorrection", name="Torus{}CC".format(index),
            defaultCompliance=1.0e-5, useOdeSolverIntegrationFactors=True)
    elif SOLVER == "LDL":
        pass  # nothing to add (GenericCC in solver node)
    elif SOLVER == "EIGENDOMAIN":
        linsolver = node.createObject(
            "EigenLLTDomainSolver", mstate=dofs_mstate.getPath())
        correction = node.createObject(
            "GenericConstraintCorrection", name="Torus{}CC".format(index))
    else:
        raise "Invalid SOLVER value " + SOLVER

    # collision
    if not COLLISION:
        collision_models = []
    elif (CM.startswith("SOFA")):
        surface_node = node.createChild("Surface")
        if CM.endswith("LMD"):
            surface_topology = surface_node.createObject(
                "MeshTopology",
                name="Torus{}SurfTopo".format(index))
            surface_topology.position.setParent(collision_rest_position)
            surface_topology.triangles.setParent(collision_triangles)
        else:
            surface_topology = surface_node.createObject(
                "TriangleSetTopologyContainer",
                name="Torus{}SurfTopo".format(index))
            surface_topology.position.setParent(collision_rest_position)
            surface_topology.triangles.setParent(collision_triangles)
            surface_node.createObject(
                "TriangleSetTopologyModifier", name="Torus{}SurfMod".format(index))
        surface_mstate = surface_node.createObject(
            "MechanicalObject", template="Vec3",
            name="Torus{}SurfState".format(index))
        surface_mstate.rest_position.setParent(collision_rest_position)
        surface_node.createObject(
            "TriangleSetGeometryAlgorithms",
            name="Torus{}SurfAlgo".format(index))
        surface_mapping = surface_node.createObject(
            "BarycentricMapping", name="Torus{}SurfMap".format(index),
            useRestPosition=True,
            mapForces=False, mapMasses=False, mapConstraints=True)
        if CM == "SOFA":
            collision_node = surface_node
            collision_models = [ collision_node.createObject(
                "TriangleModel", name="Torus{}CM".format(index)) ]
        elif CM == "SOFALMD":
            collision_node = surface_node
            collision_models = [
                collision_node.createObject(
                    "TriangleModel", name="Torus{}CMTriangle".format(index)),
                collision_node.createObject(
                    "LineModel", name="Torus{}CMLine".format(index)),
                collision_node.createObject(
                    "PointModel", name="Torus{}CMPoint".format(index))]
        for collision_model in collision_models:
            collision_model.findData('proximity').value = 0.02 * SCENE_SCALE
            collision_model.findData('color').value = [ c * 0.7 for c in object_color ]
            collision_model.findData('group').value = index+1
    else:
        raise "Invalid CM value " + CM

    # visual
    if VISUAL:
        material = material_from_color(object_color)
        if COLLISION and visual_mesh == collision_mesh:
            visual_node = surface_node.createChild("Visual")
        else:
            visual_node = node.createChild("Visual")
        visual_model = visual_node.createObject(
            "OglModel", name="Torus{}VM".format(index),
            material=material, handleDynamicTopology=False,
            handleTopologyChange=False, initRestPositions=True)
        visual_model.position.setParent(visual_rest_position)
        visual_model.triangles.setParent(visual_triangles)
        if COLLISION and visual_mesh == collision_mesh:
            visual_mapping = visual_node.createObject(
                "IdentityMapping", name="Torus{}VMMap".format(index))
        else:
            visual_mapping = visual_node.createObject(
                "BarycentricMapping", name="Torus{}VMMap".format(index),
                useRestPosition=True)

    # controller (if needed)
    if velocity[1] < 0 and translation[1] > FALL_HFIXED:
        # objects higher than 20 units are fixed by a temporary constraint, so
        # that they arrive with more distance to each other
        start_time = (translation[1]-FALL_HFIXED)/(-velocity[1])
        fixed_constraint = node.createObject(
            "FixedConstraint", name="Torus{}Fixed".format(index),
            fixAll=True, indices=[])
        # collision_model.active.value = False
        controller = EnableAfterController(
            node, "Torus{}Controller".format(index), start_time,
            fixed_constraint, collision_model)

    return node


def add_obstacle(node, index, translation, line_mesh, radius, surface_mesh):
    # input (transforms)
    line_rest_position = line_mesh.position
    line_edges = line_mesh.edges
    line_transform = node.createObject(
        "TransformEngine", name="Cyl{}LineXForm".format(index))
    line_transform.input_position.setParent(line_rest_position)
    line_transform.translation.setValue(list(translation))
    line_position = line_transform.output_position

    surface_triangles = surface_mesh.triangles
    surface_rest_position = surface_mesh.position
    surface_transform = node.createObject(
        "TransformEngine", name="Cyl{}SurfXForm".format(index))
    surface_transform.input_position.setParent(surface_rest_position)
    surface_transform.translation.setValue(list(translation))
    surface_position = surface_transform.output_position

    # collision
    if COLLISION:
        collision_node = node.createChild("Collision")
        if CM.endswith("LMD"):
            collision_topology = collision_node.createObject(
                "MeshTopology", name="Cyl{}LineTopo".format(index))
            collision_topology.position.setParent(line_rest_position)
            collision_topology.edges.setParent(line_edges)
        else:
            collision_topology = collision_node.createObject(
                "EdgeSetTopologyContainer", name="Cyl{}LineTopo".format(index))
            collision_topology.position.setParent(line_rest_position)
            collision_topology.edges.setParent(line_edges)
        collision_mstate = collision_node.createObject(
            "MechanicalObject", template="Vec3",
            name="Cyl{}LineState".format(index))
        collision_mstate.rest_position.setParent(line_rest_position)
        collision_mstate.position.setParent(line_position)
        collision_node.createObject(
            "EdgeSetGeometryAlgorithms", name="Cyl{}LineAlgo".format(index))
        if CM.startswith("SOFA"):
            collision_node.createObject(
                "LineModel", name="Cyl{}CM".format(index),
                proximity=radius, moving=False, simulated=False)
            if CM == "SOFALMD":
                collision_node.createObject(
                    "PointModel", name="Cyl{}CMP".format(index),
                    proximity=radius, moving=False, simulated=False)

    # visual
    if VISUAL:
        material = material_from_color(OBSTACLE_COLOR)
        visual_node = node.createChild("Visual")
        visual_model = visual_node.createObject(
            "OglModel", name="Cyl{}VM".format(index),
            material=material)
        visual_model.position.setParent(surface_position)
        visual_model.triangles.setParent(surface_triangles)

    return node


def add_floor(node, translation, dim):

    pmin = np.array(translation)-0.5*np.array(dim)
    pmax = np.array(translation)+0.5*np.array(dim)
    # collision
    if COLLISION:
        collision_node = node.createChild("Collision")
        if CM.endswith("LMD"):
            collision_topo = collision_node.createObject(
                "MeshTopology", name="FloorTopo")
        else:
            collision_topo = collision_node.createObject(
                "TriangleSetTopologyContainer", name="FloorTopo")
        collision_topo.position.setValue([
            [pmin[0], translation[1], pmin[2]],
            [pmax[0], translation[1], pmin[2]],
            [pmax[0], translation[1], pmax[2]],
            [pmin[0], translation[1], pmax[2]],
        ])
        collision_topo.triangles.setValue([[0, 2, 1], [3, 2, 0]])
        collision_mstate = collision_node.createObject(
            "MechanicalObject", template="Vec3", name="FloorCMState")
        collision_model = collision_node.createObject(
            "TriangleModel", name="FloorCM",
            proximity=dim[1]*0.5, moving=False, simulated=False)
        if CM == "SOFALMD":
            collision_node.createObject(
                "LineModel", name="FloorCML",
                proximity=dim[1]*0.5, moving=False, simulated=False)
            collision_node.createObject(
                "PointModel", name="FloorCMP",
                proximity=dim[1]*0.5, moving=False, simulated=False)

    # visual
    if VISUAL:
        material = FLOOR_MATERIAL
        visual_node = node.createChild("Visual")
        visual_topo = visual_node.createObject(
            "RegularGrid", name="FloorTopo", n="20 1 20",
            min=" ".join([str(c) for c in [pmax[0], pmax[1], pmin[2]]]),
            max=" ".join([str(c) for c in [pmin[0], pmax[1], pmax[2]]]))
        visual_model = visual_node.createObject(
            "OglModel", name="FloorVM", material=material)
    return node


# define environment of the simulation
def add_simulation(root_node):
    if ALOOP == "FREEMOTION":
        simulation = sofasimulation.FreeMotionSimulation(root_node)
        MT = False
    elif ALOOP == "FREEMOTIONTASK":
        simulation = sofasimulation.FreeMotionTaskSimulation(root_node)
        MT = True
    else:
        raise "Invalid ALOOP value " + ALOOP
    simulation.dt.value = 0.01
    simulation.constraint_tolerance.value = 1e-9
    simulation.constraint_max_iterations.value = 100
    simulation.gravity.value = (0, -100, 0)
    if MT:
        simulation.threadsCount.value = NBTHREAD
        # show tasks
        simulation.animation_loop.showTasks.value = True
        simulation.animation_loop.timeScale.value = 0.2
    root_node.createObject('VisualStyle', displayFlags="hideBehaviorModels \
        hideForceFields showInteractionForceFields hideMechanicalMappings \
        hideCollisionModels")
    if COLLISION:
        collision = sofasimulation.CollisionPipeline(root_node, MT, (CM.endswith("LMD")))
        collision.set_contact_distance(0.02)
        collision.set_alarm_distance(2.5)
        if CM == "SOFA":
            collision.contact_manager.response.value = "FrictionContact"
        collision.contact_manager.responseParams.value = \
            "mu={}".format(CONTACT_MU)
    return simulation


####################
# createScene
####################

def createScene(root_node):

    simulation = add_simulation(root_node)

    # input meshes ( + scaling by SCENE_SCALE)
    mesh_node = root_node.createChild("Mesh")

    torus_collision_mesh = mesh_node.createObject(
        "MeshObjLoader", name="MeshTorus1C",
        filename=torus_collision_mesh_file, scale3d=[SCENE_SCALE]*3,
        triangulate=True)
    if torus_visual_mesh_file == torus_collision_mesh_file:
        torus_visual_mesh = torus_collision_mesh
    else:
        torus_visual_mesh = mesh_node.createObject(
            "MeshObjLoader", name="MeshTorus1V",
            filename=torus_visual_mesh_file, scale3d=[SCENE_SCALE]*3,
            triangulate=True)
    torus_stuffing_surface_mesh = mesh_node.createObject(
        "MeshObjLoader", name="MeshTorus1D05",
        filename=torus_dilated_mesh_file, scale3d=[SCENE_SCALE]*3,
        triangulate=True)
    torus_volume_mesh = mesh_node.createObject(
        "MeshTetraStuffing", name="MeshStuffing",
        size=torus_volume_cell_size, alphaLong=0.4, alphaShort=0.4,
        snapPoints=False, splitTetras=False, draw=False)
    torus_volume_mesh.inputPoints.setParent(
        torus_stuffing_surface_mesh.position)
    torus_volume_mesh.inputTriangles.setParent(
        torus_stuffing_surface_mesh.triangles)
    torus_volume_mesh.inputQuads.setParent(
        torus_stuffing_surface_mesh.quads)
    # manually initializing here fails for some reason (and is not clean...)
    # print("Generating volume stuffing mesh...")
    # torus_stuffing_surface_mesh.init()
    # torus_volume_mesh.init()
    # print("DOFLEVEL {}: {} points, {} elements, {} cell size".format(
    #     DOFLEVEL, len(torus_volume_mesh.outputPoints.value),
    #     len(torus_volume_mesh.outputTetrahedra.value),
    #     torus_volume_mesh.size.value))

    cylinder_scale = SCENE_SCALE * 0.65  # make the cylinders 35% smaller
    cylinder_mesh = mesh_node.createObject(
        "MeshObjLoader", name="MeshCylinder",
        filename=cylinder_visual_mesh_file, scale3d=[cylinder_scale]*3,
        triangulate=True, handleSeams=True)
    cylinder_line = mesh_node.createObject(
        "EdgeSetTopologyContainer", name="LineCylinder",
        position=[[0.0, 0.0, 0.0], [0.0, 9.5*cylinder_scale, 0.0]],
        edges=[[0, 1]])
    cylinder_radius = 1.0*cylinder_scale

    # objects
    # create solver groups first
    solvers = [
        add_solver(root_node.createChild("Solver{}".format(index)), index)
        for index in range(NBSOLVER)]

    objects_pos = []
    objects = []
    for index in range(NBOBJECT):
        valid = False
        while not valid:
            pos = np.array([rrand(-FALL_RADIUS, FALL_RADIUS),
                            FALL_H0 + index * FALL_INTERVAL,
                            rrand(-FALL_RADIUS, FALL_RADIUS)])
            valid = pos[0]*pos[0]+pos[2]*pos[2] <= FALL_RADIUS*FALL_RADIUS
            for prevpos in objects_pos[-4:]:
                valid &= (np.dot(pos-prevpos, pos-prevpos) >=
                          FALL_MINDIST*FALL_MINDIST)
        valid = False
        while not valid:
            rot = np.array([rrand(-90, 90), rrand(-90, 90), rrand(-90, 90)])
            valid = rot[0]*rot[0] + rot[2]*rot[2] >= 30*30
        vel = [0.0, -FALL_V0, 0.0]
        objects_pos.append(pos)
        objects.append(add_object(
            solvers[index % NBSOLVER].createChild("Torus{}".format(index)),
            index, pos, rot, vel, torus_volume_mesh, torus_collision_mesh,
            torus_visual_mesh))

    # obstacles
    obstables_node = root_node.createChild("Obstables")
    for index in range(NBOBSTACLE):
        angle = (2.0*pi*index)/NBOBSTACLE
        pos = np.array([cos(angle) * OBSTACLE_RADIUS, 0.0,
                        sin(angle) * OBSTACLE_RADIUS])
        node = add_obstacle(obstables_node.createChild("Cyl{}".format(index)),
                            index, pos, cylinder_line, cylinder_radius,
                            cylinder_mesh)
    floor_node = add_floor(
        root_node.createChild("Floor"), [0.0, -0.5*SCENE_SCALE, 0.0],
        [200.0*SCENE_SCALE, 1.0*SCENE_SCALE, 200.0*SCENE_SCALE])
    floor_node.tags.value = "NoBBox"

    if VISUAL:
        root_node.createObject(
            "LightManager", name="LightManager", listening=True, shadows=False,
            ambient=[1, 1, 1, 1])
        root_node.createObject(
            "SpotLight", name="Light0", position=[-50, 800, -180],
            direction=[0, -1, 0], shadowTextureSize=4096, zNear=300, zFar=1200,
            attenuation=0.0001)
        root_node.createObject(
            "SpotLight", name="Light1", position=[0, 800, 800],
            direction=[0, -0.5, -0.25], shadowTextureSize=4096, zNear=800,
            zFar=1600, attenuation=0.0001)
        # root_node.createObject(
        #     "OglShadowShader")

    return root_node
